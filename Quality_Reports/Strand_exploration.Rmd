
## Strand exploratory analysis

### What is the idea behind the strand cross - correlation


According to [ChIP-seq guidelines and practices of the ENCODE and modENCODE consortia](http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3431496/), a useful quality metric is the use of strand cross - correlation. Which is based in the fact that a high-quality ChIP-Seq experiment produces significant clustering of enriched DNA sequence tags at locations bound by the protein of interest, and that the sequence tag density acumulates in both strand centered around the binding site.

A graphical explanation of this effect is given in the figure 5 of [Carroll et. al. 2014's paper](http://journal.frontiersin.org/Journal/10.3389/fgene.2014.00075/full):

![plot of fraglen est. by cross - corr.](figure/fromPaper/figure5-carroll-2014.jpg)

In this figure we can see an ideal case of the fragment length estimation by the use of the cross correlation function. On the top panel we can see a very smooth cross correlation function that shows both the an artifact peak and a fragment peak. In the bottom panels we can see (from left to right):
- An under estimation of the shift between both strands, which makes the pooled peak of both strands wider and therefore harder to recognize the binding event signal. In this case the fragment length is under-estimated as a the shift size where the artifact peak is ocurring.
- Just right, the shift is estimated at the peak of the cross correlation function. Which makes the signal to be higher and more recognizable when both strand reads are pooled.
- The shift is over-estimated. Which makes to have a "bimodal" peak when both strands are pooled.


### Description of the experiment

```{r package_options, include=FALSE}
opts_knit$set(progress = TRUE, verbose = TRUE)
```

```{r init,include = FALSE,echo = TRUE,results = "hide"}
library(GenomicAlignments)
library(parallel)
library(knitr)
dr ="/NO_BACKUP/KelesGroup_DongjunChung/ChIP-exo/Landick_ChIP-exo3/rawdata"
folder = c("ChIPexo","ChIPseq_PET","ChIPseq_SET")
files = lapply(folder,function(x,dr){
  ff = list.files(file.path(dr,x))
  return(ff[!grepl("bai",ff) & !grepl("sam",ff)])},dr)
names(files) = folder
ff = lapply(folder,function(x,dr,files)file.path(dr,x,files[[x]]),dr,files)
names(ff) = folder
design = data.frame(Rep = c(rep(1,4),rep(2,4)),Rif = rep(c(0,0,20,20),2),IP = rep(c("Sigma70","BetaPrimeFlag"),4),
  exo.edns = c(1311,1312,1314,1315,1317,1318,1320,1321),pet.edsn = seq(1396,1403))
betaF = data.frame(Rep = c(1,1,2,2),Rif = c(0,20,0,20),IP = rep("Beta",4),exo.edns = c(1310,1313,1316,1319))
start = c(576875,798921,1152674,1192831,1820005,2310506,2996662,3351853,3973436,4262028)
end = c(577492,799434,1153291,1193448,1820696,2311153,2997175,3352366,3973949,4262541)
peaks = GRanges(seqnames = "U00096",ranges = IRanges(start = start,end = end),strand = "*")
width(peaks) = 1000
```
In this experiment we are trying to check how the effect explained above occurrs for reads generated by the ChIP - exo protocol. For that purpose, the following regions where visually located using the e. coli genome viewer Mochi-view:

```{r show_peaks,include= TRUE,echo = FALSE,results = "asis"}
kable(as.data.frame(peaks),format = "markdown")
```

For the inspection the following structures where considered:


```{r show_df,include = TRUE,echo = FALSE,results = "asis"}
kable(design,format = "markdown")
```

Using the following function, we generated the strand coverage across for all peaks, for all data sets. The coverage was calculated using the function:

```{r coverage_fun,include = TRUE,results = "hide",echo = TRUE}
strand_coverage <- function(reads,peak,st, fragLen = 0)
{
  reads = as(reads,"GRanges")
  reads = subset(reads, subset = strand(reads) == st)
  if(fragLen >0){
    reads = resize(reads,fragLen)
  }
  match = subjectHits(findOverlaps(peak,reads))
  cover = coverage(reads[match])[[1]]
  x = seq(start(peak),end(peak))
  if(nrun(cover) == 1){
    y = rep(runValue(cover),length(x))
  }else{
    xp = cumsum(runLength(cover)[1:(nrun(cover)-1)])
    yp = runValue(cover)
    y = stepfun(xp,yp)(x)
  }
  return(y)
}
```





